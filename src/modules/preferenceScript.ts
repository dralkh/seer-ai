import { config } from "../../package.json";
import { getString } from "../utils/locale";
import {
  getModelConfigs,
  addModelConfig,
  updateModelConfig,
  deleteModelConfig,
  setDefaultModelConfig,
  validateModelConfig,
} from "./chat/modelConfig";
import { AIModelConfig } from "./chat/types";

// Track selected model config ID
let selectedConfigId: string | null = null;
const HTML_NS = "http://www.w3.org/1999/xhtml";

/**
 * Helper function to get CSS variable value
 */
function getCssVar(name: string): string {
  const win = addon.data.prefs!.window;
  const doc = win.document;
  const rootElement = doc.documentElement;
  if (!rootElement) return '';
  const styles = win.getComputedStyle(rootElement);
  if (!styles) return '';
  return styles.getPropertyValue(name).trim() || '';
}

export async function registerPrefsScripts(_window: Window) {
  // This function is called when the prefs window is opened
  // See addon/content/preferences.xhtml onpaneload
  if (!addon.data.prefs) {
    addon.data.prefs = {
      window: _window,
      columns: [
        {
          dataKey: "title",
          label: getString("prefs-table-title"),
          fixedWidth: true,
          width: 100,
        },
        {
          dataKey: "detail",
          label: getString("prefs-table-detail"),
        },
      ],
      rows: [
        {
          title: "Orange",
          detail: "It's juicy",
        },
        {
          title: "Banana",
          detail: "It's sweet",
        },
        {
          title: "Apple",
          detail: "I mean the fruit APPLE",
        },
      ],
    };
  } else {
    addon.data.prefs.window = _window;
  }
  updatePrefsUI();
  bindPrefEvents();
  initModelConfigUI();
}

async function updatePrefsUI() {
  // You can initialize some UI elements on prefs window
  // with addon.data.prefs.window.document
  // Or bind some events to the elements
  const renderLock = ztoolkit.getGlobal("Zotero").Promise.defer();
  if (addon.data.prefs?.window == undefined) return;
  const tableHelper = new ztoolkit.VirtualizedTable(addon.data.prefs?.window)
    .setContainerId(`${config.addonRef}-table-container`)
    .setProp({
      id: `${config.addonRef}-prefs-table`,
      // Do not use setLocale, as it modifies the Zotero.Intl.strings
      // Set locales directly to columns
      columns: addon.data.prefs?.columns,
      showHeader: true,
      multiSelect: true,
      staticColumns: true,
      disableFontSizeScaling: true,
    })
    .setProp("getRowCount", () => addon.data.prefs?.rows.length || 0)
    .setProp(
      "getRowData",
      (index) =>
        addon.data.prefs?.rows[index] || {
          title: "no data",
          detail: "no data",
        },
    )
    // Show a progress window when selection changes
    .setProp("onSelectionChange", (selection) => {
      new ztoolkit.ProgressWindow(config.addonName)
        .createLine({
          text: `Selected line: ${addon.data.prefs?.rows
            .filter((v, i) => selection.isSelected(i))
            .map((row) => row.title)
            .join(",")}`,
          progress: 100,
        })
        .show();
    })
    // When pressing delete, delete selected line and refresh table.
    // Returning false to prevent default event.
    .setProp("onKeyDown", (event: KeyboardEvent) => {
      if (event.key == "Delete" || (Zotero.isMac && event.key == "Backspace")) {
        addon.data.prefs!.rows =
          addon.data.prefs?.rows.filter(
            (v, i) => !tableHelper.treeInstance.selection.isSelected(i),
          ) || [];
        tableHelper.render();
        return false;
      }
      return true;
    })
    // For find-as-you-type
    .setProp(
      "getRowString",
      (index) => addon.data.prefs?.rows[index].title || "",
    )
    // Render the table.
    .render(-1, () => {
      renderLock.resolve();
    });
  await renderLock.promise;
  ztoolkit.log("Preference table rendered!");
}

function bindPrefEvents() {
  const doc = addon.data.prefs!.window.document;
  const prefPrefix = config.prefsPrefix;

  // Helper to bind an input element to a preference
  function bindInput(inputId: string, prefKey: string) {
    const input = doc?.querySelector(`#${inputId}`) as HTMLInputElement | null;
    if (!input) return;

    // Load current value from preferences
    const currentValue = Zotero.Prefs.get(`${prefPrefix}.${prefKey}`) as string;
    input.value = currentValue ?? "";

    // Save value when changed
    input.addEventListener("change", () => {
      Zotero.Prefs.set(`${prefPrefix}.${prefKey}`, input.value);
      ztoolkit.log(`Saved ${prefKey}: ${input.value}`);
    });
  }

  // Helper to bind a checkbox element to a boolean preference
  function bindCheckbox(checkboxId: string, prefKey: string) {
    const checkbox = doc?.querySelector(`#${checkboxId}`) as HTMLInputElement | null;
    if (!checkbox) return;

    // Load current value from preferences
    const currentValue = Zotero.Prefs.get(`${prefPrefix}.${prefKey}`) as boolean;
    checkbox.checked = currentValue ?? false;

    // Save value when changed
    checkbox.addEventListener("command", () => {
      Zotero.Prefs.set(`${prefPrefix}.${prefKey}`, checkbox.checked);
      ztoolkit.log(`Saved ${prefKey}: ${checkbox.checked}`);
    });
  }

  // Function to show/hide settings based on mode selection
  function updateModeVisibility(mode: string) {
    const localSettings = doc?.querySelector(`#zotero-prefpane-${config.addonRef}-localSettings`) as HTMLElement;
    const cloudSettings = doc?.querySelector(`#zotero-prefpane-${config.addonRef}-cloudSettings`) as HTMLElement;
    const mistralSettings = doc?.querySelector(`#zotero-prefpane-${config.addonRef}-mistralSettings`) as HTMLElement;

    if (localSettings) {
      localSettings.style.display = mode === "local" ? "" : "none";
    }
    if (cloudSettings) {
      cloudSettings.style.display = mode === "cloud" ? "" : "none";
    }
    if (mistralSettings) {
      mistralSettings.style.display = mode === "mistral" ? "" : "none";
    }
  }

  // Bind menulist for mode selection
  const modeSelect = doc?.querySelector(`#zotero-prefpane-${config.addonRef}-datalabMode`) as XUL.MenuList;
  if (modeSelect) {
    // Load current value from preference (fallback to datalabUseLocal for backward compat)
    let currentMode = Zotero.Prefs.get(`${prefPrefix}.datalabMode`) as string;
    if (!currentMode) {
      // Backward compatibility: check old boolean preference
      const useLocal = Zotero.Prefs.get(`${prefPrefix}.datalabUseLocal`) as boolean;
      currentMode = useLocal ? "local" : "cloud";
    }
    modeSelect.value = currentMode;
    updateModeVisibility(currentMode);

    // Save on change
    modeSelect.addEventListener("command", () => {
      const newMode = modeSelect.value;
      Zotero.Prefs.set(`${prefPrefix}.datalabMode`, newMode);
      // Also update boolean for backward compat
      Zotero.Prefs.set(`${prefPrefix}.datalabUseLocal`, newMode === "local");
      updateModeVisibility(newMode);
      ztoolkit.log(`Saved datalabMode: ${newMode}`);
    });
  }

  // Bind other DataLab settings
  bindInput(`zotero-prefpane-${config.addonRef}-datalabUrl`, "datalabUrl");
  bindInput(`zotero-prefpane-${config.addonRef}-datalabApiKey`, "datalabApiKey");
  bindInput(`zotero-prefpane-${config.addonRef}-mistralApiKey`, "mistralApiKey");


  // AI Insights settings
  bindCheckbox(`zotero-prefpane-${config.addonRef}-searchAutoAiInsights`, "searchAutoAiInsights");
  bindInput(`zotero-prefpane-${config.addonRef}-searchAiInsightsPrompt`, "searchAiInsightsPrompt");
  bindInput(`zotero-prefpane-${config.addonRef}-searchAiInsightsResponseLength`, "searchAiInsightsResponseLength");

  // Bind menulist for citation style
  const styleSelect = doc?.querySelector(`#zotero-prefpane-${config.addonRef}-searchAiInsightsCitationStyle`) as XUL.MenuList;
  if (styleSelect) {
    styleSelect.value = Zotero.Prefs.get(`${prefPrefix}.searchAiInsightsCitationStyle`) as string || "numbered";
    styleSelect.addEventListener("command", () => {
      Zotero.Prefs.set(`${prefPrefix}.searchAiInsightsCitationStyle`, styleSelect.value);
    });
  }

  // Local-specific settings
  bindCheckbox(`zotero-prefpane-${config.addonRef}-localForceOcr`, "localForceOcr");

  // Cloud-specific settings
  bindCheckbox(`zotero-prefpane-${config.addonRef}-cloudForceOcr`, "cloudForceOcr");
  bindCheckbox(`zotero-prefpane-${config.addonRef}-cloudUseLlm`, "cloudUseLlm");

  // Semantic Scholar settings
  bindInput(`zotero-prefpane-${config.addonRef}-semanticScholarApiKey`, "semanticScholarApiKey");

  // Firecrawl settings
  bindInput(`zotero-prefpane-${config.addonRef}-firecrawlApiKey`, "firecrawlApiKey");
  bindInput(`zotero-prefpane-${config.addonRef}-firecrawlApiUrl`, "firecrawlApiUrl");
  bindInput(`zotero-prefpane-${config.addonRef}-firecrawlSearchLimit`, "firecrawlSearchLimit");

  // Tavily settings
  bindInput(`zotero-prefpane-${config.addonRef}-tavilyApiKey`, "tavilyApiKey");
  bindInput(`zotero-prefpane-${config.addonRef}-tavilySearchLimit`, "tavilySearchLimit");

  // Tavily search depth menulist
  const tavilyDepthSelect = doc?.querySelector(`#zotero-prefpane-${config.addonRef}-tavilySearchDepth`) as XUL.MenuList;
  if (tavilyDepthSelect) {
    tavilyDepthSelect.value = Zotero.Prefs.get(`${prefPrefix}.tavilySearchDepth`) as string || "basic";
    tavilyDepthSelect.addEventListener("command", () => {
      Zotero.Prefs.set(`${prefPrefix}.tavilySearchDepth`, tavilyDepthSelect.value);
    });
  }

  // Web Search Provider selection with show/hide logic
  function updateWebSearchProviderVisibility(provider: string) {
    const firecrawlSettings = doc?.querySelector(`#zotero-prefpane-${config.addonRef}-firecrawlSettings`) as HTMLElement;
    const tavilySettings = doc?.querySelector(`#zotero-prefpane-${config.addonRef}-tavilySettings`) as HTMLElement;

    if (firecrawlSettings) {
      firecrawlSettings.style.display = provider === "firecrawl" ? "" : "none";
    }
    if (tavilySettings) {
      tavilySettings.style.display = provider === "tavily" ? "" : "none";
    }
  }

  const webSearchProviderSelect = doc?.querySelector(`#zotero-prefpane-${config.addonRef}-webSearchProvider`) as XUL.MenuList;
  if (webSearchProviderSelect) {
    const currentProvider = Zotero.Prefs.get(`${prefPrefix}.webSearchProvider`) as string || "firecrawl";
    webSearchProviderSelect.value = currentProvider;
    updateWebSearchProviderVisibility(currentProvider);

    webSearchProviderSelect.addEventListener("command", () => {
      Zotero.Prefs.set(`${prefPrefix}.webSearchProvider`, webSearchProviderSelect.value);
      updateWebSearchProviderVisibility(webSearchProviderSelect.value);
      ztoolkit.log(`Saved webSearchProvider: ${webSearchProviderSelect.value}`);
    });
  }

  // Initialize MCP Integration UI
  initMcpIntegrationUI();

  // Initialize Advanced Data Management UI
  try {
    initAdvancedDataManagementUI();
  } catch (e) {
    Zotero.debug(`[seerai] Error initializing Advanced Data Management UI: ${e}`);
  }
}

/**
 * Initialize MCP Integration UI
 */
function initMcpIntegrationUI() {
  const doc = addon.data.prefs!.window.document;
  const configArea = doc.getElementById(`zotero-prefpane-${config.addonRef}-mcpConfigJson`) as any; // HTMLTextAreaElement
  const copyBtn = doc.getElementById(`zotero-prefpane-${config.addonRef}-copyMcpConfig`);

  if (!configArea) return;

  // Default config showing structure
  const mcpConfig = {
    "mcpServers": {
      "seerai-zotero": {
        "command": "node",
        "args": ["/absolute/path/to/seerai-mcp.cjs"]
      }
    }
  };

  configArea.value = JSON.stringify(mcpConfig, null, 2);

  copyBtn?.addEventListener("command", () => {
    // Copy to clipboard
    try {
      const clipboard = (Components.classes as any)["@mozilla.org/widget/clipboardhelper;1"]
        .getService((Components.interfaces as any).nsIClipboardHelper);
      clipboard.copyString(configArea.value);

      // Visual feedback
      const originalLabel = copyBtn.getAttribute("label");
      copyBtn.setAttribute("label", "Copied!");
      setTimeout(() => {
        copyBtn.setAttribute("label", originalLabel || "Copy Config to Clipboard");
      }, 2000);
    } catch (e) {
      addon.data.prefs!.window.alert("Failed to copy to clipboard");
      console.error(e);
    }
  });
}

/**
 * Initialize Advanced Data Management UI (Export/Import)
 */
function initAdvancedDataManagementUI() {
  const doc = addon.data.prefs!.window.document;
  const exportBtn = doc.getElementById(`zotero-prefpane-${config.addonRef}-exportConfig`);
  const importBtn = doc.getElementById(`zotero-prefpane-${config.addonRef}-importConfig`);

  if (!exportBtn || !importBtn) return;

  // Use the API exposed in index.ts
  // @ts-ignore
  const { exportAllData, importAllData } = Zotero.SeerAI.api.ConfigManager;

  exportBtn.addEventListener("command", async () => {
    try {
      const data = await exportAllData();
      const json = JSON.stringify(data, null, 2);

      const win = addon.data.prefs!.window;
      const Cc = (Components as any).classes;
      const Ci = (Components as any).interfaces;

      const fp = Cc["@mozilla.org/filepicker;1"].createInstance(Ci.nsIFilePicker);
      fp.init(win, "Export Seer-AI Configuration", Ci.nsIFilePicker.modeSave);
      fp.appendFilter("JSON Files", "*.json");
      fp.defaultString = `seerai-config-${new Date().toISOString().slice(0, 10)}.json`;

      const res = await new Promise((resolve) => fp.open(resolve));
      if (res !== Ci.nsIFilePicker.returnCancel && fp.file) {
        // @ts-ignore
        await IOUtils.writeUTF8(fp.file.path, json);
        Zotero.debug(`[seerai] Exported config to ${fp.file.path}`);
      }
    } catch (e) {
      Zotero.debug(`[seerai] Export failed: ${e}`);
      addon.data.prefs!.window.alert(`Export failed: ${e}`);
    }
  });

  importBtn.addEventListener("command", async () => {
    try {
      const win = addon.data.prefs!.window;
      const Cc = (Components as any).classes;
      const Ci = (Components as any).interfaces;

      const fp = Cc["@mozilla.org/filepicker;1"].createInstance(Ci.nsIFilePicker);
      fp.init(win, "Import Seer-AI Configuration", Ci.nsIFilePicker.modeOpen);
      fp.appendFilter("JSON Files", "*.json");

      const res = await new Promise((resolve) => fp.open(resolve));
      if (res !== Ci.nsIFilePicker.returnCancel && fp.file) {
        // @ts-ignore
        const json = await IOUtils.readUTF8(fp.file.path);
        const data = JSON.parse(json);

        if (
          win.confirm(
            "This will overwrite your current Seer-AI configuration (preferences, tables, prompts). Are you sure?",
          )
        ) {
          const result = await importAllData(data);
          if (result.success) {
            win.alert(
              `Import Successful!\n${result.stats}\nPlease restart Zotero/Seer-AI for all changes to take full effect.`,
            );
          } else {
            win.alert(`Import Failed: ${result.error}`);
          }
        }
      }
    } catch (e) {
      Zotero.debug(`[seerai] Import failed: ${e}`);
      addon.data.prefs!.window.alert(`Import failed: ${e}`);
    }
  });
}

/**
 * Initialize Model Configuration UI
 */
function initModelConfigUI() {
  const doc = addon.data.prefs!.window.document;

  // Render the model list
  renderModelList();

  // Bind button events
  const addBtn = doc?.querySelector(`#zotero-prefpane-${config.addonRef}-models-add`);
  const editBtn = doc?.querySelector(`#zotero-prefpane-${config.addonRef}-models-edit`);
  const deleteBtn = doc?.querySelector(`#zotero-prefpane-${config.addonRef}-models-delete`);
  const defaultBtn = doc?.querySelector(`#zotero-prefpane-${config.addonRef}-models-default`);

  addBtn?.addEventListener("command", () => {
    showModelConfigDialog();
  });

  editBtn?.addEventListener("command", () => {
    if (selectedConfigId) {
      const cfg = getModelConfigs().find(c => c.id === selectedConfigId);
      if (cfg) showModelConfigDialog(cfg);
    }
  });

  deleteBtn?.addEventListener("command", () => {
    if (selectedConfigId) {
      const configs = getModelConfigs();
      const cfg = configs.find(c => c.id === selectedConfigId);
      if (cfg && addon.data.prefs!.window.confirm(`Delete "${cfg.name}"?`)) {
        deleteModelConfig(selectedConfigId);
        selectedConfigId = null;
        renderModelList();
        updateButtonStates();
      }
    }
  });

  defaultBtn?.addEventListener("command", () => {
    if (selectedConfigId) {
      setDefaultModelConfig(selectedConfigId);
      renderModelList();
    }
  });
}

/**
 * Render the model configurations list
 */
function renderModelList() {
  const doc = addon.data.prefs!.window.document;
  const listContainer = doc?.querySelector(`#${config.addonRef}-models-list`);
  const emptyMsg = doc?.querySelector(`#${config.addonRef}-models-empty`);

  if (!listContainer) return;

  // Clear existing items (except empty message)
  const existingItems = listContainer.querySelectorAll('.model-config-item');
  existingItems.forEach((item: Element) => item.remove());

  const configs = getModelConfigs();

  if (configs.length === 0) {
    if (emptyMsg) (emptyMsg as HTMLElement).style.display = 'block';
    return;
  }

  if (emptyMsg) (emptyMsg as HTMLElement).style.display = 'none';

  configs.forEach(cfg => {
    const item = doc.createElementNS(HTML_NS, 'div') as HTMLElement;
    item.className = 'model-config-item';
    item.setAttribute('data-id', cfg.id);

    // Get CSS variables for theme-aware colors
    const itemBg = cfg.isDefault ? getCssVar('--model-item-bg-default') : getCssVar('--model-item-bg');
    const itemBorder = selectedConfigId === cfg.id
      ? getCssVar('--model-item-border-selected')
      : (cfg.isDefault ? getCssVar('--model-item-border-default') : getCssVar('--model-item-border'));
    const accentColor = getCssVar('--model-item-accent');
    const secondaryTextColor = getCssVar('--model-item-text-secondary');

    item.style.cssText = `
      padding: 8px 12px;
      margin: 4px 0;
      border-radius: 4px;
      cursor: pointer;
      background: ${itemBg};
      border: 1px solid ${itemBorder};
      display: flex;
      justify-content: space-between;
      align-items: center;
    `;

    const info = doc.createElementNS(HTML_NS, 'div') as HTMLElement;
    info.innerHTML = `
      <strong style="font-size: 13px;">${escapeHtml(cfg.name)}</strong>
      ${cfg.isDefault ? `<span style="color: ${accentColor}; font-size: 11px; margin-left: 8px;">★ Default</span>` : ''}
      <div style="font-size: 11px; color: ${secondaryTextColor}; margin-top: 2px;">
        ${escapeHtml(cfg.model)} • ${escapeHtml(new URL(cfg.apiURL).hostname)}
      </div>
    `;

    item.appendChild(info);
    item.addEventListener('click', () => {
      selectedConfigId = cfg.id;
      renderModelList();
      updateButtonStates();
    });

    listContainer.appendChild(item);
  });
}

/**
 * Update button enabled states based on selection
 */
function updateButtonStates() {
  const doc = addon.data.prefs!.window.document;
  const editBtn = doc?.querySelector(`#zotero-prefpane-${config.addonRef}-models-edit`) as HTMLButtonElement;
  const deleteBtn = doc?.querySelector(`#zotero-prefpane-${config.addonRef}-models-delete`) as HTMLButtonElement;
  const defaultBtn = doc?.querySelector(`#zotero-prefpane-${config.addonRef}-models-default`) as HTMLButtonElement;

  const hasSelection = selectedConfigId !== null;
  if (editBtn) editBtn.disabled = !hasSelection;
  if (deleteBtn) deleteBtn.disabled = !hasSelection;
  if (defaultBtn) defaultBtn.disabled = !hasSelection;
}

/**
 * Show dialog to add/edit model configuration
 * Uses a single modal with all fields visible at once
 */
function showModelConfigDialog(existingConfig?: AIModelConfig) {
  const isEdit = !!existingConfig;
  const title = isEdit ? "Edit Model Configuration" : "Add Model Configuration";
  const doc = addon.data.prefs!.window.document;
  const win = addon.data.prefs!.window;

  // Remove any existing modal
  const existingModal = doc.getElementById('model-config-modal-overlay');
  if (existingModal) existingModal.remove();

  // Get CSS variables for modal colors
  const modalBg = getCssVar('--modal-bg');
  const modalTitleColor = getCssVar('--modal-title-color');

  // Detect color scheme for fallbacks
  const isDark = !!(win?.matchMedia?.('(prefers-color-scheme: dark)')?.matches);
  const defaultBg = isDark ? '#1e1e1e' : '#ffffff';
  const defaultTitleColor = isDark ? '#eeeeee' : '#111111';

  // Create modal overlay
  const overlay = doc.createElementNS(HTML_NS, 'div') as HTMLElement;
  overlay.id = 'model-config-modal-overlay';
  overlay.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
  `;

  // Create modal container
  const modal = doc.createElementNS(HTML_NS, 'div') as HTMLElement;
  modal.style.cssText = `
    background: ${modalBg || defaultBg};
    color: ${modalTitleColor || defaultTitleColor};
    border-radius: 8px;
    padding: 24px;
    min-width: 420px;
    max-width: 500px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    border: 1px solid rgba(255, 255, 255, 0.1);
  `;

  // Modal title
  const titleEl = doc.createElementNS(HTML_NS, 'h3') as HTMLElement;
  titleEl.textContent = title;
  titleEl.style.cssText = `
    margin: 0 0 20px 0;
    font-size: 18px;
    font-weight: 600;
    color: ${modalTitleColor || defaultTitleColor};
  `;
  modal.appendChild(titleEl);

  // Provider presets
  const providerPresets = [
    { name: '— Select a preset —', apiURL: '', model: '', placeholder: '' },
    { name: 'OpenAI', apiURL: 'https://api.openai.com/v1/', model: 'gpt-5-mini', placeholder: 'sk-...' },
    { name: 'Anthropic', apiURL: 'https://api.anthropic.com/v1/', model: 'claude-sonnet-4.5', placeholder: 'sk-ant-...' },
    { name: 'Google AI (Gemini)', apiURL: 'https://generativelanguage.googleapis.com/v1beta/openai/', model: 'gemini-2.5-flash', placeholder: 'AIza...' },
    { name: 'Mistral AI', apiURL: 'https://api.mistral.ai/v1/', model: 'mistral-large-latest', placeholder: '' },
    { name: 'OpenRouter', apiURL: 'https://openrouter.ai/api/v1/', model: 'openai/gpt-5-mini', placeholder: 'sk-or-...' },
    { name: 'Groq', apiURL: 'https://api.groq.com/openai/v1/', model: 'openai/gpt-oss-120b', placeholder: 'gsk_...' },
    { name: 'DeepSeek', apiURL: 'https://api.deepseek.com/v1/', model: 'deepseek-chat', placeholder: 'sk-...' },
    { name: 'xAI (Grok)', apiURL: 'https://api.x.ai/v1/', model: 'grok-4.1-fast', placeholder: 'xai-...' },
    { name: 'Together AI', apiURL: 'https://api.together.xyz/v1/', model: 'openai/gpt-oss-120b', placeholder: '' },
    { name: 'Ollama (Local)', apiURL: 'http://localhost:11434/v1/', model: 'qwen3-vl:8b-thinking-q8_0', placeholder: '(optional)' },
    { name: 'OpenAI Compatible', apiURL: 'http://seerai.com:1234/v1/', model: 'local-model', placeholder: '(optional)' },
  ];

  // Get CSS variables for form elements
  const labelColor = getCssVar('--modal-label-color');
  const inputBg = getCssVar('--modal-input-bg');
  const inputBorder = getCssVar('--modal-input-border');
  const inputFocusBorder = getCssVar('--modal-input-focus-border');
  const inputText = getCssVar('--modal-input-text');
  const inputPlaceholder = getCssVar('--modal-input-placeholder');

  // Field styles
  const labelStyle = `
    display: block;
    font-size: 13px;
    font-weight: 500;
    color: ${labelColor || defaultTitleColor};
    margin-bottom: 4px;
  `;
  const inputStyle = `
    width: 100%;
    padding: 10px 12px;
    border: 1px solid ${inputBorder || (isDark ? '#444' : '#ccc')};
    border-radius: 6px;
    font-size: 14px;
    margin-bottom: 16px;
    box-sizing: border-box;
    transition: border-color 0.2s;
    background: ${inputBg || (isDark ? '#2d2d2d' : '#ffffff')};
    color: ${inputText || defaultTitleColor};
  `;
  const selectStyle = `
    width: 100%;
    padding: 10px 12px;
    border: 1px solid ${inputBorder || (isDark ? '#444' : '#ccc')};
    border-radius: 6px;
    font-size: 14px;
    margin-bottom: 16px;
    box-sizing: border-box;
    background: ${inputBg || (isDark ? '#2d2d2d' : '#ffffff')};
    color: ${inputText || defaultTitleColor};
    cursor: pointer;
  `;

  // Preset selector (only show for new configs)
  const inputs: Record<string, HTMLInputElement> = {};

  if (!isEdit) {
    const presetLabel = doc.createElementNS(HTML_NS, 'label') as HTMLElement;
    presetLabel.textContent = 'Provider Preset';
    presetLabel.style.cssText = labelStyle;
    modal.appendChild(presetLabel);

    const presetSelect = doc.createElementNS(HTML_NS, 'select') as HTMLSelectElement;
    presetSelect.style.cssText = selectStyle;

    providerPresets.forEach((preset, idx) => {
      const option = doc.createElementNS(HTML_NS, 'option') as HTMLOptionElement;
      option.value = String(idx);
      option.textContent = preset.name;
      presetSelect.appendChild(option);
    });

    presetSelect.addEventListener('change', () => {
      const idx = parseInt(presetSelect.value);
      const preset = providerPresets[idx];
      if (preset && idx > 0) {
        if (inputs.name && !inputs.name.value) inputs.name.value = preset.name;
        if (inputs.apiURL) inputs.apiURL.value = preset.apiURL;
        if (inputs.model) inputs.model.value = preset.model;
        if (inputs.apiKey) inputs.apiKey.placeholder = preset.placeholder || 'API Key';
      }
    });

    modal.appendChild(presetSelect);

    // Divider
    const dividerBg = getCssVar('--divider-bg');
    const dividerTextBg = getCssVar('--divider-text-bg');
    const dividerTextColor = getCssVar('--divider-text-color');

    const divider = doc.createElementNS(HTML_NS, 'div') as HTMLElement;
    divider.style.cssText = `
      border-top: 1px solid ${dividerBg};
      margin: 4px 0 16px 0;
      position: relative;
    `;
    const dividerText = doc.createElementNS(HTML_NS, 'span') as HTMLElement;
    dividerText.textContent = 'or fill manually';
    dividerText.style.cssText = `
      position: absolute;
      top: -9px;
      left: 50%;
      transform: translateX(-50%);
      background: ${dividerTextBg};
      padding: 0 12px;
      font-size: 11px;
      color: ${dividerTextColor};
    `;
    divider.appendChild(dividerText);
    modal.appendChild(divider);
  }

  // Create form fields
  const fields = [
    { id: 'name', label: 'Name', placeholder: 'My OpenAI Config', value: existingConfig?.name || '', type: 'text' },
    { id: 'apiURL', label: 'API URL', placeholder: 'https://api.openai.com/v1/', value: existingConfig?.apiURL || 'https://api.openai.com/v1/', type: 'text' },
    { id: 'apiKey', label: 'API Key', placeholder: 'sk-...', value: existingConfig?.apiKey || '', type: 'password' },
    { id: 'model', label: 'Model', placeholder: 'gpt-4o-mini', value: existingConfig?.model || 'gpt-4o-mini', type: 'text' },
  ];

  fields.forEach(field => {
    const label = doc.createElementNS(HTML_NS, 'label') as HTMLElement;
    label.textContent = field.label;
    label.style.cssText = labelStyle;
    modal.appendChild(label);

    const input = doc.createElementNS(HTML_NS, 'input') as HTMLInputElement;
    input.type = field.type;
    input.placeholder = field.placeholder;
    input.value = field.value;
    input.style.cssText = inputStyle;
    input.id = `model-config-${field.id}`;
    inputs[field.id] = input;
    modal.appendChild(input);

    // Add focus effect
    input.addEventListener('focus', () => {
      input.style.borderColor = inputFocusBorder;
      input.style.outline = 'none';
    });
    input.addEventListener('blur', () => {
      input.style.borderColor = inputBorder;
    });
  });

  // --- Rate Limit Section ---
  const rlLabel = doc.createElementNS(HTML_NS, 'label') as HTMLElement;
  rlLabel.textContent = 'Rate Limit';
  rlLabel.style.cssText = labelStyle;
  modal.appendChild(rlLabel);

  const rlContainer = doc.createElementNS(HTML_NS, 'div') as HTMLElement;
  rlContainer.style.cssText = `
    display: flex;
    gap: 12px;
    margin-bottom: 16px;
  `;

  // Type Selector
  const rlTypeSelect = doc.createElementNS(HTML_NS, 'select') as HTMLSelectElement;
  rlTypeSelect.style.cssText = selectStyle;
  rlTypeSelect.style.marginBottom = '0';
  rlTypeSelect.style.flex = '1';

  const rlTypes = [
    { value: 'concurrency', label: 'Concurrency (Simultaneous)' },
    { value: 'rpm', label: 'RPM (Requests / Minute)' },
    { value: 'tpm', label: 'TPM (Tokens / Minute)' }
  ];

  rlTypes.forEach(t => {
    const opt = doc.createElementNS(HTML_NS, 'option') as HTMLOptionElement;
    opt.value = t.value;
    opt.textContent = t.label;
    if (existingConfig?.rateLimit?.type === t.value) {
      opt.selected = true;
    }
    rlTypeSelect.appendChild(opt);
  });
  rlContainer.appendChild(rlTypeSelect);

  // Value Input
  const rlValueInput = doc.createElementNS(HTML_NS, 'input') as HTMLInputElement;
  rlValueInput.type = 'number';
  rlValueInput.min = '1';
  rlValueInput.placeholder = 'Limit';
  rlValueInput.value = existingConfig?.rateLimit?.value ? String(existingConfig.rateLimit.value) : '5';
  rlValueInput.style.cssText = inputStyle;
  rlValueInput.style.marginBottom = '0';
  rlValueInput.style.flex = '1';

  // Add focus effect
  rlValueInput.addEventListener('focus', () => {
    rlValueInput.style.borderColor = inputFocusBorder;
    rlValueInput.style.outline = 'none';
  });
  rlValueInput.addEventListener('blur', () => {
    rlValueInput.style.borderColor = inputBorder;
  });

  rlContainer.appendChild(rlValueInput);
  modal.appendChild(rlContainer);

  // --- Reasoning Effort Section ---
  const reLabel = doc.createElementNS(HTML_NS, 'label') as HTMLElement;
  reLabel.textContent = 'Reasoning Effort (for o1/o3/reasoning models)';
  reLabel.style.cssText = labelStyle;
  modal.appendChild(reLabel);

  const reSelect = doc.createElementNS(HTML_NS, 'select') as HTMLSelectElement;
  reSelect.style.cssText = selectStyle;

  const reOptions = [
    { value: '', label: 'Disabled (Use Provider Default)' },
    { value: 'low', label: 'Low' },
    { value: 'medium', label: 'Medium' },
    { value: 'high', label: 'High' }
  ];

  reOptions.forEach(opt => {
    const option = doc.createElementNS(HTML_NS, 'option') as HTMLOptionElement;
    option.value = opt.value;
    option.textContent = opt.label;
    if (existingConfig?.reasoningEffort === opt.value || (!existingConfig?.reasoningEffort && opt.value === '')) {
      option.selected = true;
    }
    reSelect.appendChild(option);
  });

  modal.appendChild(reSelect);


  // Error message container
  const errorBg = getCssVar('--modal-error-bg');
  const errorText = getCssVar('--modal-error-text');

  const errorContainer = doc.createElementNS(HTML_NS, 'div') as HTMLElement;
  errorContainer.style.cssText = `
    color: ${errorText};
    font-size: 12px;
    margin-bottom: 16px;
    display: none;
    padding: 8px 12px;
    background: ${errorBg};
    border-radius: 4px;
  `;
  modal.appendChild(errorContainer);

  // Button container
  const buttonContainer = doc.createElementNS(HTML_NS, 'div') as HTMLElement;
  buttonContainer.style.cssText = `
    display: flex;
    justify-content: flex-end;
    gap: 12px;
    margin-top: 8px;
  `;

  // Get button colors
  const btnBg = getCssVar('--modal-btn-bg');
  const btnHoverBg = getCssVar('--modal-btn-hover-bg');
  const btnText = getCssVar('--modal-btn-text');
  const btnPrimaryBg = getCssVar('--modal-btn-primary-bg');
  const btnPrimaryHoverBg = getCssVar('--modal-btn-primary-hover-bg');
  const btnPrimaryText = getCssVar('--modal-btn-primary-text');
  const btnBorder = getCssVar('--modal-input-border');

  // Cancel button
  const cancelBtn = doc.createElementNS(HTML_NS, 'button') as HTMLButtonElement;
  cancelBtn.textContent = 'Cancel';
  cancelBtn.style.cssText = `
    padding: 10px 20px;
    border: 1px solid ${btnBorder};
    border-radius: 6px;
    background: ${btnBg};
    color: ${btnText};
    font-size: 14px;
    cursor: pointer;
    transition: all 0.2s;
  `;
  cancelBtn.addEventListener('mouseenter', () => {
    cancelBtn.style.background = btnHoverBg;
  });
  cancelBtn.addEventListener('mouseleave', () => {
    cancelBtn.style.background = btnBg;
  });
  cancelBtn.addEventListener('click', () => {
    overlay.remove();
  });

  // Save button
  const saveBtn = doc.createElementNS(HTML_NS, 'button') as HTMLButtonElement;
  saveBtn.textContent = isEdit ? 'Save Changes' : 'Add Configuration';
  saveBtn.style.cssText = `
    padding: 10px 20px;
    border: none;
    border-radius: 6px;
    background: ${btnPrimaryBg};
    color: ${btnPrimaryText};
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
  `;
  saveBtn.addEventListener('mouseenter', () => {
    saveBtn.style.background = btnPrimaryHoverBg;
  });
  saveBtn.addEventListener('mouseleave', () => {
    saveBtn.style.background = btnPrimaryBg;
  });

  saveBtn.addEventListener('click', () => {
    const newConfig = {
      name: inputs.name.value.trim(),
      apiURL: inputs.apiURL.value.trim(),
      apiKey: inputs.apiKey.value.trim(),
      model: inputs.model.value.trim(),
      rateLimit: {
        type: rlTypeSelect.value as 'tpm' | 'rpm' | 'concurrency',
        value: parseInt(rlValueInput.value) || 5
      },
      ...(reSelect.value && { reasoningEffort: reSelect.value as 'low' | 'medium' | 'high' })
    };

    // Validate
    const errors = validateModelConfig(newConfig);
    if (errors.length > 0) {
      errorContainer.textContent = errors.join('\n');
      errorContainer.style.display = 'block';
      return;
    }

    if (isEdit && existingConfig) {
      updateModelConfig(existingConfig.id, newConfig);
    } else {
      addModelConfig(newConfig);
    }

    overlay.remove();
    renderModelList();
    updateButtonStates();
  });

  buttonContainer.appendChild(cancelBtn);
  buttonContainer.appendChild(saveBtn);
  modal.appendChild(buttonContainer);

  // Close on overlay click
  overlay.addEventListener('click', (e) => {
    if (e.target === overlay) {
      overlay.remove();
    }
  });

  // Close on Escape key
  const handleEscape = (e: KeyboardEvent) => {
    if (e.key === 'Escape') {
      overlay.remove();
      win.removeEventListener('keydown', handleEscape);
    }
  };
  win.addEventListener('keydown', handleEscape);

  overlay.appendChild(modal);

  const container = doc.body || doc.documentElement;
  if (container) {
    container.appendChild(overlay);
  }

  // Focus first input
  inputs.name.focus();
}

/**
 * Escape HTML for safe display
 */
function escapeHtml(text: string): string {
  const div = addon.data.prefs!.window.document.createElementNS(HTML_NS, 'div') as HTMLElement;
  div.textContent = text;
  return div.innerHTML as string;
}

